<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>App设计教程 · Ai4ELab</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../democards/listtheme.css" rel="stylesheet" type="text/css"/><link href="../../assets/css/ai4e.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="Ai4ELab logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Ai4ELab</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../quickstart/">Quick Start</a></li><li class="is-active"><a class="tocitem" href>App设计教程</a><ul class="internal"><li><a class="tocitem" href="#设计逻辑"><span>设计逻辑</span></a></li><li><a class="tocitem" href="#代码剖析"><span>代码剖析</span></a></li><li><a class="tocitem" href="#总结"><span>总结</span></a></li><li><a class="tocitem" href="#建议"><span>建议</span></a></li></ul></li><li><a class="tocitem" href="../styleAndRules/">App开发规范与建议</a></li></ul></li><li><a class="tocitem" href="../../apps/">APP Show</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>App设计教程</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>App设计教程</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/ai4energy/Ai4ELab/blob/main/docs/src/tutorials/webdesign.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="App设计教程"><a class="docs-heading-anchor" href="#App设计教程">App设计教程</a><a id="App设计教程-1"></a><a class="docs-heading-anchor-permalink" href="#App设计教程" title="Permalink"></a></h1><p>在<a href="../quickstart/">Quick Start</a>之后，相信大家已经看到了Web页面，本篇依旧以<code>TestLab</code>为例，进行设计方法说明。</p><p>Stipple.jl用的是MVC框架，但是我们不涉及各种框架知识，有兴趣的同学自行查看。<strong>我们从实践的角度贯通实现APP的思想</strong>。</p><h2 id="设计逻辑"><a class="docs-heading-anchor" href="#设计逻辑">设计逻辑</a><a id="设计逻辑-1"></a><a class="docs-heading-anchor-permalink" href="#设计逻辑" title="Permalink"></a></h2><p>整个程序的运行逻辑图如图：</p><p><img src="../../assets/webdesig-09-39.png" alt="图 1"/>  </p><p>在这个逻辑的基础上解决2个问题：</p><ul><li>在交互页面选择参数，参数需要被程序监听（也就是说如果参数改变了，程序需要及时检测到）</li><li>被监听的参数传递到计算函数，函数计算出结果后页面展示结果。</li></ul><p>所以，细分可以得到如下的逻辑图：</p><p><img src="../../assets/webdesig-09-53.png" alt="图 5"/>  </p><p>那么整体的程序设计思路就是紧紧围绕这个逻辑图来进行的。</p><h2 id="代码剖析"><a class="docs-heading-anchor" href="#代码剖析">代码剖析</a><a id="代码剖析-1"></a><a class="docs-heading-anchor-permalink" href="#代码剖析" title="Permalink"></a></h2><h3 id="参数“容器”"><a class="docs-heading-anchor" href="#参数“容器”">参数“容器”</a><a id="参数“容器”-1"></a><a class="docs-heading-anchor-permalink" href="#参数“容器”" title="Permalink"></a></h3><p>所有的可变参数都放置在——mutable struct（可变参数结构体）中。这个结构体叫<code>MyPage</code>（名字任意取）。</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>可变参数本质就是被监听的变量。结构体中的成员实际上是变量，本篇中叫<strong>参数</strong>或叫<strong>变量</strong>都指的是同一个意思。</p></div></div><pre><code class="language-julia hljs">@reactive mutable struct MyPage &lt;: ReactiveModel
    # iris_data::R{DataTable} = DataTable(data)

    value::R{Int} = 0
    click::R{Int} = 0

    features::R{Vector{Symbol}} = [:_sin, :cos, :log, :tanh]
    f_left::R{Symbol} = :sin
    f_right::R{Symbol} = :sin

    plot_data::R{Vector{PlotData}} = []
    layout::R{PlotLayout} = PlotLayout(plot_bgcolor=&quot;#fff&quot;)

    x_limit::R{Int} = 3
    paramenter::R{Float32} = 1.2
end</code></pre><p>其中，用户决定的参数有：</p><ul><li><code>x_limit</code> 对应 <code>X轴范围</code></li><li><code>paramenter</code>对应 <code>函数系数</code></li><li><code>f_left</code>对应 <code>测试函数1</code></li><li><code>f_right</code>对应 <code>测试函数2</code></li><li><code>value</code>、<code>click</code> 对应 <code>SIMULATION</code>按钮</li></ul><p>储存计算的结果有：</p><ul><li><code>plot_data</code> 对应 <code>动图</code></li></ul><h3 id="生成页面函数——UI"><a class="docs-heading-anchor" href="#生成页面函数——UI">生成页面函数——UI</a><a id="生成页面函数——UI-1"></a><a class="docs-heading-anchor-permalink" href="#生成页面函数——UI" title="Permalink"></a></h3><pre><code class="language-julia hljs">function ui(model::MyApp.MyPage)

    onany(model.value) do (_...)
        model.click[] += 1
        compute_data(model)
    end

    page(model, class=&quot;container&quot;, title=&quot;Ai4Lab&quot;,
        head_content=Genie.Assets.favicon_support(),
        prepend=style(
            &quot;&quot;&quot;
            tr:nth-child(even) {
              background: #F8F8F8 !important;
            }

            .modebar {
              display: none!important;
            }

            .st-module {
              marign: 10px;
              background-color: #FFF;
              border-radius: 5px;
              box-shadow: 0px 4px 10px rgba(0, 0, 0, 0.04);
            }

            .stipple-core .st-module &gt; h5,
            .stipple-core .st-module &gt; h6 {
              border-bottom: 0px !important;
            }
            &quot;&quot;&quot;
        ),
        [
            heading(&quot;测试&quot;)
            row([
                cell(
                    class=&quot;st-module&quot;,
                    [
                        h6(&quot;X轴范围&quot;)
                        slider(1:1:20,
                            @data(:x_limit);
                            label=true)
                    ]
                )
                cell(
                    class=&quot;st-module&quot;,
                    [
                        h6(&quot;函数系数&quot;)
                        slider(1:0.1:2,
                            @data(:paramenter);
                            label=true)
                    ]
                )
                cell(
                    class=&quot;st-module&quot;,
                    [
                        h6(&quot;测试函数1&quot;)
                        Stipple.select(:f_left; options=:features)
                    ]
                )
                cell(
                    class=&quot;st-module&quot;,
                    [
                        h6(&quot;测试函数2&quot;)
                        Stipple.select(:f_right; options=:features)
                    ]
                )])
            row([
                cell(
                    class=&quot;st-module&quot;,
                    p([
                        &quot;Simulation Times: &quot;
                        span(model.click, @text(:click))
                    ])
                )
                btn(&quot;Simulation!&quot;, color=&quot;primary&quot;, textcolor=&quot;black&quot;, @click(&quot;value += 1&quot;), [
                    tooltip(contentclass=&quot;bg-indigo&quot;, contentstyle=&quot;font-size: 16px&quot;,
                        style=&quot;offset: 10px 10px&quot;, &quot;点击按钮开始仿真!&quot;)])
                cell(
                    class=&quot;st-module&quot;,
                    p([
                        &quot;Simulation Times: &quot;
                        span(model.click, @text(:click))
                    ])
                )])
            row([
                cell(
                    class=&quot;st-module&quot;,
                    [
                        h5(&quot;仿真结果：&quot;)
                        plot(:plot_data, layout=:layout, config=&quot;{ displayLogo:false }&quot;)
                    ]
                )
            ])
        ]
    )
end
</code></pre><p>ui函数中有两个重要的部分：</p><ul><li>触发——<code>onany</code></li><li>html页面——<code>page</code></li></ul><h4 id="触发"><a class="docs-heading-anchor" href="#触发">触发</a><a id="触发-1"></a><a class="docs-heading-anchor-permalink" href="#触发" title="Permalink"></a></h4><p>对于触发而言，<code>onany(model.value)</code>表示监听参数容器中<code>value</code>的值，如果这个值改变了，就进行系列计算。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>思考：如果同时监听<code>x_limit</code>、<code>paramenter</code>、<code>f_left</code>、<code>f_right</code>、<code>value</code>会有什么结果。</p></div></div><h4 id="page页面划分"><a class="docs-heading-anchor" href="#page页面划分">page页面划分</a><a id="page页面划分-1"></a><a class="docs-heading-anchor-permalink" href="#page页面划分" title="Permalink"></a></h4><p>对于页面而言，描述了整个html页面的结构。以及对应的参数绑定。 <code>page</code>中有<code>row</code>和<code>cell</code>，他们的关系如下：</p><p><img src="../../assets/webdesig-10-25.png" alt="图 6"/>  </p><p>整个页面分为3个<code>row</code>，每个<code>row</code>里面可以分出<code>cell</code>。</p><p><strong>可以向row与cell传递一些特性参数，例如size等，这些需要查阅官方文档的API。或者从代码示例中查看一些可能的用法，因为开发者本身的文档也不是很完善</strong>。</p><h4 id="page中值绑定"><a class="docs-heading-anchor" href="#page中值绑定">page中值绑定</a><a id="page中值绑定-1"></a><a class="docs-heading-anchor-permalink" href="#page中值绑定" title="Permalink"></a></h4><p>cell中，类似：</p><pre><code class="language-julia hljs"># 滑动条
slider(1:0.1:2,@data(:paramenter);label=true)
# 选择框
Stipple.select(:f_right; options=:features)</code></pre><p>它们将页面与参数容器中的变量绑定在一起了。这种绑定中自动包含监听。也就是说用户只要拖动滑动条，那么它绑定的相应值就被记录下来了。</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>记录不等于触发，只有<code>onany()</code>中的变量改变了才会触发。 换一句话说，页面中绑定的值随时都在被监听，只要改变了都被记录下来。但是触发与否，哪些值触发，由<code>onany()</code>决定。 即，监听是自动完成的，触发是人为决定的。</p></div></div><h3 id="计算函数"><a class="docs-heading-anchor" href="#计算函数">计算函数</a><a id="计算函数-1"></a><a class="docs-heading-anchor-permalink" href="#计算函数" title="Permalink"></a></h3><pre><code class="language-julia hljs">pd(f, para, xlim, name) = PlotData(
    x=Float64[i for i in 1:0.1:xlim],
    y=Float64[para * f(i) for i in 1:0.1:xlim],
    plot=StipplePlotly.Charts.PLOT_TYPE_SCATTER,
    name=name,
)
function compute_data(ic_model::MyApp.MyPage)
    f_left = isequal(ic_model.f_left[], nothing) ? sin : eval(ic_model.f_left[])
    f_right = isequal(ic_model.f_right[], nothing) ? sin : eval(ic_model.f_right[])
    xlim = ic_model.x_limit[]
    para = ic_model.paramenter[]
    for i in 0:30
        ic_model.plot_data[] = [pd(f_left, para, xlim + i, &quot;测试函数1&quot;), pd(f_right, para, xlim + i, &quot;测试函数2&quot;)]
        sleep(1 / 30)
    end
    nothing
end</code></pre><p>计算函数就干了一个活，触发以后，根据传回来的“用户决定的值”计算出相应的结果，并回传。那么就有两个问题：</p><ol><li>什么叫“根据传回来的参数”？</li><li>“回传”是怎么个“回传”法？</li></ol><h4 id="结构体中可变参数调用"><a class="docs-heading-anchor" href="#结构体中可变参数调用">结构体中可变参数调用</a><a id="结构体中可变参数调用-1"></a><a class="docs-heading-anchor-permalink" href="#结构体中可变参数调用" title="Permalink"></a></h4><p><strong>第一个问题的本质是——调用</strong>！因为前面已经说了。任何改变都会被监听并自动记录。被触发需要计算的时候，调用这些被记录的值不就可以了吗？事实上的确如此：</p><pre><code class="language-julia hljs">xlim = ic_model.x_limit[]
para = ic_model.paramenter[]</code></pre><p>例如，这两个做法就是直接调用参数容器里的参数值</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>参数容器里的参数值调用时需要带上<code>[]</code>，例如：<code>ic_model.x_limit[]</code>否则报错！</p></div></div><p>随后，调用了函数<code>pd()</code>。函数<code>pd</code>返回的是一个结构体，这个结构体叫<code>PlotData</code>。<code>PlotData</code>是非常重要的一个结构体。因为这是Web程序，画图不会直接画，而是需要把画图的数据存下来，生成相关的css和js文件，再在浏览器中显示。<strong>所以需要<code>PlotData</code>这样一个中间体来存储画图的数据</strong>。</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>对于Web程序来说，最终目的是展示结果。也可以说，生成这个<code>PlotData</code>是触发函数计算最终的目的。当然，也有存在其他的展示形式，如表格等等。本质上是一样的。</p></div></div><h4 id="参数回传"><a class="docs-heading-anchor" href="#参数回传">参数回传</a><a id="参数回传-1"></a><a class="docs-heading-anchor-permalink" href="#参数回传" title="Permalink"></a></h4><p><strong>第二个问题的本质是——赋值</strong>！把计算出来的<code>PlotData</code>结果赋值给参数容器中的<code>plot_data</code>，实现传递。随后它就在与之绑定的页面区域中显示出来。也就是说，页面的监听是双向的。用户通过滑动条改变参数“容器”参数是可以的，后台计算程序改变参数“容器”参数也是可以的。无论哪一方改变了，都没有问题，页面都会做出相应的改变。</p><p>例如：</p><pre><code class="language-julia hljs"> for i in 0:30
     ic_model.plot_data[] = [pd(f_left, para, xlim + i, &quot;测试函数1&quot;), pd(f_right, para, xlim + i, &quot;测试函数2&quot;)]
     sleep(1 / 30)
 end</code></pre><p>这里通过for循环，连续得到30个<code>PlotData</code>并赋值给<code>plot_data[]</code>，只要赋值了，页面就会显示。此外，中间休息<span>$\frac{1}{30}$</span>秒。这不就是动画的原理吗？</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>参数容器里的参数值被赋值时需要带上<code>[]</code>，例如：<code>ic_model.plot_data[]</code>否则报错！</p></div></div><h2 id="总结"><a class="docs-heading-anchor" href="#总结">总结</a><a id="总结-1"></a><a class="docs-heading-anchor-permalink" href="#总结" title="Permalink"></a></h2><p>与逻辑图<strong>不同</strong>的是，程序的<strong>框架</strong>如下：</p><p><img src="../../assets/webdesig-11-57.png" alt="图 7"/>  </p><p>如果仔细思考可以发现，最关的键其实是我们的可变结构体：</p><pre><code class="language-julia hljs">@reactive mutable struct MyPage &lt;: ReactiveModel</code></pre><p>这个结构体是整个App交互的一个桥梁。交互时发生的变化，全部体现在这里面的参数（变量）的变化上。当需要设计一个App时，考虑交互的动态参数，其实就是在设计这个结构体的成员。</p><p>只要产生交互，就要设计变量放入“参数容器”中。</p><p>例如，本例中的两个滑杆，两个选择框，一个按钮。以及画图区域。这些是交互的组件，那么就要设计相应的变量来“承载交互”。</p><h2 id="建议"><a class="docs-heading-anchor" href="#建议">建议</a><a id="建议-1"></a><a class="docs-heading-anchor-permalink" href="#建议" title="Permalink"></a></h2><p>本篇贯穿了App设计的理念。但对于一些细节不可能面面俱到。不太明白的话，对着代码看效果，努力思考为什么这么写能行。还有一些细节上的疑问，可以通过改动代码看页面的变化来琢磨它的机制。从实践中体会，这是理解最快的方式。同时积极参照官方文档及API。</p><p>从教程调试建议中看一看，学习方法。</p><p>可以多多思考，为什么这么写能行；如果要实现XXX，应该要怎么做；那么做能不能实现等等。</p><p><strong>发挥想象力，带着问题去探索实践，慢慢地，就悟了!</strong>💪💪💪</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quickstart/">« Quick Start</a><a class="docs-footer-nextpage" href="../styleAndRules/">App开发规范与建议 »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Monday 19 September 2022 01:59">Monday 19 September 2022</span>. Using Julia version 1.8.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
